<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: canvax.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: canvax.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*

Canvax.JS

License information (OMv2-FO): https://github.com/omnent/omnent-licenses/blob/master/licenses/OMv2-FO.txt

Copyright 2017 Ethan Davis

Permission is hereby granted, for free, to any person obtaining a copy of this software and associated documentation files (collectively "the Software" or "THE SOFTWARE"), to (without restriction) use, modify, copy, publish, execute, distribute, sublicense, and sell the Software and to allow people who gain access to the Software to do the same as long as this entire license and the above copyright notice are included in all copies or portions of the Software.

NOTWITHSTANDING ANYTHING IN CONTRADICTION, THE AUTHORS AND COPYRIGHT HOLDERS OF THE SOFTWARE SHALL UNDER NO CIRCUMSTANCES BE HELD LIABLE FOR ANY DAMAGES, CLAIM, OR OTHER LIABILITY RELATED TO, IN CONNECTION WITH, OR CAUSED BY USE OR DISTRIBUTION OF THE SOFTWARE. THE SOFTWARE IS PROVIDED "AS-IS" AND IS NOT PROVIDED WITH WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, AND ANY WARRANTY ARISING OUR OF PRIOR COURSE OF DEALING AND USAGE OF TRADE.

*/

/**
* Canvax library
* @public
* @namespace
*/
const canvax = {
	"_imageCache": {},
	/**
	* Tests if an object is an HTMLElement
	* @private
	* @function
	* @param {Object} obj - Object to test
	* @returns {Boolean}
	*/
	"_isElement": (obj) => {
		try {
			return obj instanceof HTMLElement;
		}
		catch (err) {
			return (typeof obj === "object" &amp;&amp; obj.hasOwnProperty("nodeType"));
		}
	},
	"_pointDistance": (p1, p2) => { // [x, y] format
		return Math.sqrt(Math.pow(Math.abs(p1[0] - p2[0]), 2) + Math.pow(Math.abs(p1[1] - p2[1]), 2));
	},
	/**
	* Renders an entity to a renderer's canvas
	* @private
	* @function
	* @param {canvax.Renderer} renderer
	* @param {canvax.Rectangle|canvax.Circle} entity
	*/
	"_renderEntityToCanvas": (renderer, entity) => {
		// TODO render whatever

		var ctx = renderer.ctx;

		switch (entity.type) {
			case "Rectangle":
				if (entity.backgroundColor !== "none") {
					ctx.fillStyle = entity.backgroundColor;
					ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
				}
				if (entity.borderWeight !== "0" &amp;&amp; entity.borderColor !== "none") {
					ctx.strokeStyle = entity.borderColor;
					ctx.lineWidth = entity.borderWeight;
					ctx.strokeRect(entity.x, entity.y, entity.width, entity.height);
				}
				break;
			case "Circle":
				ctx.beginPath();
				ctx.arc(entity.x, entity.y, entity.radius, 0, 2 * Math.PI, false);
				if (entity.backgroundColor !== "none") {
					ctx.fillStyle = entity.backgroundColor;
					ctx.fill();
				}
				if (entity.borderWeight !== "0" &amp;&amp; entity.borderColor !== "none") {
					ctx.strokeStyle = entity.borderColor;
					ctx.lineWidth = entity.borderWeight;
					ctx.stroke();
				}
				break;
			case "Ellipse":
				var kappa = .5522847493;
				var ox = (entity.width / 2) * kappa;
				var oy = (entity.height / 2) * kappa;
				var xe = entity.x + entity.width;
				var ye = entity.y + entity.height;
				var xm = entity.x + entity.width / 2;
				var ym = entity.y + entity.height / 2;

				ctx.beginPath();
				ctx.moveTo(entity.x, ym);
				ctx.bezierCurveTo(entity.x, ym - oy, xm - ox, entity.y, xm, entity.y);
				ctx.bezierCurveTo(xm + ox, entity.y, xe, ym - oy, xe, ym);
				ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
				ctx.bezierCurveTo(xm - ox, ye, entity.x, ym + oy, entity.x, ym);
				ctx.closePath();

				if (entity.backgroundColor !== "none") {
					ctx.fillStyle = entity.backgroundColor;
					ctx.fill();
				}
				if (entity.borderWeight !== "0" &amp;&amp; entity.borderColor !== "none") {
					ctx.strokeStyle = entity.borderColor;
					ctx.lineWidth = entity.borderWeight;
					ctx.stroke();
				}
				break;
			case "Image":
				if (canvax._imageCache.hasOwnProperty(entity.source)) {
					var imageSource = canvax._imageCache[entity.source];
				}
				else {
					var imageSource = new Image();
					imageSource.src = entity.source;

					canvax._imageCache[entity.source] = imageSource;
				}
				ctx.drawImage(imageSource, entity.x, entity.y, entity.width, entity.height);
				break;
			case "CustomEntity":
				entity.entityMethod(ctx, entity.properties);
				break;
			default:
				break;
		}
	},
	/**
	* Renders entities to canvas by passing them to _renderEntityToCanvas
	* @private
	* @function
	* @param {canvax.Renderer} renderer
	* @param {Array.&lt;canvax.Rectangle|canvax.Circle>} entities
	*/
	"_renderEntitiesToCanvas": (renderer, entities) => {
		for (let i = 0; i &lt; entities.length; i++) {
			canvax._renderEntityToCanvas(renderer, entities[i]);
		}
	},
	"_clearCanvas": (renderer, element) => {
		renderer.ctx.clearRect(0, 0, element.width, element.height);
	},
	// TODO add collision detection method
	// Renderer class
	/**
	* Returns a renderer object for a canvas element.
	* @public
	* @function
	* @param {HTMLCanvasElement} canvas - Canvas element
	* @property {Array.&lt;canvax.Rectangle|canvax.Circle>} entities
	* @property {HTMLCanvasElement} element
	* @property {CanvasRenderingContext2D} ctx
	* @property {function} add - (renderEntity): Adds an entity to the canvax Renderer
	* @property {function} clear - (): Removes all entities from the canvax Renderer
	* @property {function} render - (): Renders all entities to the Renderer canvas
	*/
	"Renderer": function(element) {
		if (canvax._isElement(element) &amp;&amp; element.getContext) {
			this.entities = [];
			this.element = element;
			this.ctx = element.getContext("2d");
			this.add = (renderEntity) => {
				this.entities.push(renderEntity);
			};
			this.clear = () => {
				this.entities = [];
			};
			this.render = () => {
				canvax._clearCanvas(this, this.element);
				canvax._renderEntitiesToCanvas(this, this.entities);
			}
		}
		else {
			throw new Error("element is not a canvas element.");
		}
	},
	// Entities
	/**
	* Returns a Rectangle entity.
	* @public
	* @class
	* @param {number} x
	* @param {number} y
	* @param {string} width
	* @param {string} height
	* @param {string} [backgroundColor=none] - Background color of entity ('none' to render no background)
	* @param {string} [borderColor=#000000]  - Border color of entity ('none' to render no border)
	* @param {number} [borderWeight=3] - Border weight of entity in space units ('0' to render no border)
	* @property {number} x
	* @property {number} y
	* @property {number} width
	* @property {number} height
	* @property {string} backgroundColor
	* @property {string} borderColor
	* @property {string} borderWeight
	* @property {function} setPosition - (x, y)
	* @property {function} setSize - (width, height)
	*/
	"Rectangle": function(x, y, width, height, backgroundColor, borderColor, borderWeight) {
		if (typeof x !== "undefined" &amp;&amp; typeof y !== "undefined" &amp;&amp; typeof width !== "undefined" &amp;&amp; typeof height !== "undefined") {
			this.type = "Rectangle";

			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;

			this.backgroundColor = (backgroundColor || "none");
			this.borderColor = (borderColor || "#000000");
			this.borderWeight = (borderWeight || "0px");

			// Update methods

			this.setPosition = (xset, yset) => {
				this.x = xset;
				this.y = yset;
			};

			this.setSize = (widthSet, heightSet) => {
				this.width = widthSet;
				this.height = heightSet;
			};

			this.getBounds = () => {
				return {
					"l": this.x - this.width / 2,
					"t": this.y + this.height / 2,
					"r": this.x + this.width / 2,
					"b": this.y - this.height / 2,
				};
			};
		}
		else {
			throw new Error("Missing position parameter.");
		}
	},
	/**
	* Returns a Circle entity.
	* @public
	* @class
	* @param {number} x
	* @param {number} y
	* @param {string} radius
	* @param {string} [backgroundColor=none] - Background color of entity ('none' to render no background)
	* @param {string} [borderColor=#000000]  - Border color of entity ('none' to render no border)
	* @param {number} [borderWeight=3] - Border weight of entity in space units ('0' to render no border)
	* @property {number} x
	* @property {number} y
	* @property {number} radius
	* @property {string} backgroundColor
	* @property {string} borderColor
	* @property {string} borderWeight
	* @property {function} setPosition - (x, y)
	*/
	"Circle": function(x, y, radius, backgroundColor, borderColor, borderWeight) {
		if (typeof x !== "undefined" &amp;&amp; typeof y !== "undefined" &amp;&amp; typeof radius !== "undefined") {
			this.type = "Circle";

			this.x = x;
			this.y = y;
			this.radius = radius;

			this.backgroundColor = (backgroundColor || "none");
			this.borderColor = (borderColor || "#000000");
			this.borderWeight = (borderWeight || "0px");

			// Update methods

			this.setPosition = (xset, yset) => {
				this.x = xset;
				this.y = yset;
			};

			this.getBounds = () => {
				var halfRadius = this.radius / 2;
				return {
					"l": this.x - halfRadius,
					"t": this.y + halfRadius,
					"r": this.x + halfRadius,
					"b": this.y - halfRadius,
				};
			};
		}
		else {
			throw new Error("Missing position parameter.");
		}
	},
	/**
	* Returns an Ellipse entity.
	* @public
	* @class
	* @param {number} x
	* @param {number} y
	* @param {number} width
	* @param {number} height
	* @param {string} [backgroundColor=none] - Background color of entity ('none' to render no background)
	* @param {string} [borderColor=#000000]  - Border color of entity ('none' to render no border)
	* @param {number} [borderWeight=3] - Border weight of entity in space units ('0' to render no border)
	* @property {number} x
	* @property {number} y
	* @property {number} width
	* @property {number} height
	* @property {string} backgroundColor
	* @property {string} borderColor
	* @property {string} borderWeight
	* @property {function} setPosition - (x, y)
	* @property {function} setSize - (width, height)
	*/
	"Ellipse": function(x, y, width, height, backgroundColor, borderColor, borderWeight) {
		if (typeof x !== "undefined" &amp;&amp; typeof y !== "undefined" &amp;&amp; typeof width !== "undefined" &amp;&amp; typeof height !== "undefined") {
			this.type = "Ellipse";

			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;

			this.backgroundColor = (backgroundColor || "none");
			this.borderColor = (borderColor || "#000000");
			this.borderWeight = (borderWeight || "0px");

			// Update methods

			this.setPosition = (xset, yset) => {
				this.x = xset;
				this.y = yset;
			};

			this.setSize = (widthSet, heightSet) => {
				this.width = widthSet;
				this.height = heightSet;
			};

			this.getBounds = () => {
				return {
					"l": this.x - this.width / 2,
					"t": this.y + this.height / 2,
					"r": this.x + this.width / 2,
					"b": this.y - this.height / 2,
				};
			};
		}
		else {
			throw new Error("Missing position parameter.");
		}
	},
	/**
	* Returns an Image entity.
	* @public
	* @class
	* @param {number} x - X coordinate of top left corner of image location
	* @param {number} y - Y coordinate of top left corner of image location
	* @param {number} width
	* @param {number} height
	* @param {string} source
	* @property {number} x - X coordinate of top left corner of image location
	* @property {number} y - Y coordinate of top left corner of image location
	* @property {number} width
	* @property {number} height
	* @property {string} source - Image source
	* @property {function} setPosition - (x, y)
	* @property {function} setSize - (width, height)
	*/
	"Image": function(x, y, width, height, source) {
		if (typeof x !== "undefined" &amp;&amp; typeof y !== "undefined" &amp;&amp; typeof width !== "undefined" &amp;&amp; typeof height !== "undefined" &amp;&amp; source) {
			this.type = "Image";

			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.source = source;

			// Update methods

			this.setPosition = (xset, yset) => {
				this.x = xset;
				this.y = yset;
			};

			this.setSize = (widthSet, heightSet) => {
				this.width = widthSet;
				this.height = heightSet;
			};

			this.getBounds = () => {
				return {
					"l": this.x,
					"t": this.y,
					"r": this.x + this.width,
					"b": this.y - this.height,
				};
			};
		}
		else {
			throw new Error("Missing required Image configuration parameter.");
		}
	},
	/**
	* Returns a custom entity.
	* @public
	* @class
	* @param {function} customEntityMethod - (CanvasRenderingContext2D, properties)
	* @param {Object} properties - Set of custom properties to pass to customEntityMethod on render
	*/
	"Entity": function(customEntityMethod, properties) {
		if (customEntityMethod) {
			this.type = "CustomEntity";

			this.entityMethod = customEntityMethod;

			this.properties = properties || {};
		}
		else {
			throw new Error("Missing entity method.");
		}
	}
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="canvax.Circle.html">Circle</a></li><li><a href="canvax.Ellipse.html">Ellipse</a></li><li><a href="canvax.Entity.html">Entity</a></li><li><a href="canvax.Image.html">Image</a></li><li><a href="canvax.Rectangle.html">Rectangle</a></li></ul><h3>Namespaces</h3><ul><li><a href="canvax.html">canvax</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Mon Jul 31 2017 12:25:50 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
