// Note: This is not currently minified. This should be temporary.

"use strict";

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var canvax = function () {
  var build = {};
  var module = {};

  module.exports =
  /*#__PURE__*/
  function () {
    function Circle(options) {
      _classCallCheck(this, Circle);

      this.type = 'circle';
      Object.assign(this, {
        'x': 0,
        'y': 0,
        'radius': 100,
        'backgroundColor': null,
        'borderColor': '#E74C3C',
        'borderWeight': 0
      }, options);
    }

    _createClass(Circle, [{
      key: "render",
      value: function render(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);

        if (typeof this.backgroundColor === 'string') {
          ctx.fillStyle = this.backgroundColor;
          ctx.fill();
        }

        if (typeof this.borderColor === 'string' && typeof this.borderWeight === 'number' && this.borderWeight > 0) {
          ctx.strokeStyle = this.borderColor;
          ctx.lineWidth = this.borderWeight;
          ctx.stroke();
        }
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        if (entity.type === 'circle') {
          return this._pointDistance([this.x, this.y], [entity.x, entity.y]) < this.radius + entity.radius;
        } else if (entity.type === 'rectangle' || entity.type === 'image') {
          // Adapted from https://yal.cc/rectangle-circle-intersection-test/
          var deltaX = this.x - Math.max(entity.x, Math.min(this.x, entity.x + entity.width));
          var deltaY = this.y - Math.max(entity.y, Math.min(this.y, entity.y + entity.height));
          return Math.pow(deltaX, 2) + Math.pow(deltaY, 2) < Math.pow(this.radius, 2);
        } else throw new Error('Cannot check touches for type ' + entity.type + '.');
      }
    }, {
      key: "_pointDistance",
      value: function _pointDistance(p1, p2) {
        return Math.sqrt(Math.pow(Math.abs(p1[0] - p2[0]), 2) + Math.pow(Math.abs(p1[1] - p2[1]), 2));
      }
    }]);

    return Circle;
  }();

  build['Circle'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function () {
    function Ellipse(options) {
      _classCallCheck(this, Ellipse);

      this.type = 'ellipse';
      Object.assign(this, {
        'x': 0,
        'y': 0,
        'width': 100,
        'height': 100,
        'backgroundColor': null,
        'borderColor': '#E74C3C',
        'borderWeight': 0
      }, options);
    }

    _createClass(Ellipse, [{
      key: "render",
      value: function render(ctx) {
        var kappa = .5522847493;
        var ox = this.width / 2 * kappa;
        var oy = this.height / 2 * kappa;
        var xe = this.x + this.width;
        var ye = this.y + this.height;
        var xm = this.x + this.width / 2;
        var ym = this.y + this.height / 2;
        ctx.beginPath();
        ctx.moveTo(this.x, ym);
        ctx.bezierCurveTo(this.x, ym - oy, xm - ox, this.y, xm, this.y);
        ctx.bezierCurveTo(xm + ox, this.y, xe, ym - oy, xe, ym);
        ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        ctx.bezierCurveTo(xm - ox, ye, this.x, ym + oy, this.x, ym);
        ctx.closePath();

        if (typeof this.backgroundColor === 'string') {
          ctx.fillStyle = this.backgroundColor;
          ctx.fill();
        }

        if (typeof this.borderColor === 'string' && typeof this.borderWeight === 'number' && this.borderWeight > 0) {
          ctx.strokeStyle = this.borderColor;
          ctx.lineWidth = this.borderWeight;
          ctx.stroke();
        }
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        throw new Error('Cannot check touches for type ' + this.type + '.');
      }
    }]);

    return Ellipse;
  }();

  build['Ellipse'] = module.exports;
  var __canvaxImageCache = {};

  module.exports =
  /*#__PURE__*/
  function () {
    function Image(options) {
      _classCallCheck(this, Image);

      this.type = 'image';
      Object.assign(this, {
        'x': 0,
        'y': 0,
        'source': ''
      }, options); // 'width' and 'height' options will be undefined by default.
    }

    _createClass(Image, [{
      key: "render",
      value: function render(ctx) {
        var _this = this;

        ctx.rotate(this.rotation * Math.PI / 180);
        var imageSource;

        if (__canvaxImageCache.hasOwnProperty(this.source)) {
          if (__canvaxImageCache[this.source] === false) return;
          imageSource = __canvaxImageCache[this.source];
          ctx.drawImage(imageSource, this.x, this.y, this.width, this.height);
        } else {
          __canvaxImageCache[this.source] = false;
          imageSource = document.createElement('img');
          imageSource.src = this.source;

          imageSource.onload = function () {
            __canvaxImageCache[_this.source] = imageSource;
            ctx.drawImage(imageSource, _this.x, _this.y, _this.width, _this.height);
          };
        }
      }
    }, {
      key: "getBounds",
      value: function getBounds() {
        return {
          'l': this.x,
          't': this.y,
          'r': this.x + this.width,
          'b': this.y - this.height
        };
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        if (entity.type === 'rectangle' || entity.type === 'image') {
          var myBounds = this.getBounds();
          var checkBounds = entity.getBounds();
          return !(myBounds.t < checkBounds.b || myBounds.b > checkBounds.t || myBounds.r < checkBounds.l || myBounds.l > checkBounds.r);
        } else if (entity.type === 'circle') {
          // Adapted from https://yal.cc/rectangle-circle-intersection-test/
          var deltaX = entity.x - Math.max(this.x, Math.min(entity.x, this.x + this.width));
          var deltaY = entity.y - Math.max(this.y, Math.min(entity.y, this.y + this.height));
          return Math.pow(deltaX, 2) + Math.pow(deltaY, 2) < Math.pow(entity.radius, 2);
        } else throw new Error('Cannot check touches for type ' + entity.type + '.');
      }
    }]);

    return Image;
  }();

  build['Image'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function () {
    function Rectangle(options) {
      _classCallCheck(this, Rectangle);

      this.type = 'rectangle';
      Object.assign(this, {
        'x': 0,
        'y': 0,
        'width': 100,
        'height': 100,
        'backgroundColor': null,
        'borderColor': '#E74C3C',
        'borderWeight': 0
      }, options);
    }

    _createClass(Rectangle, [{
      key: "render",
      value: function render(ctx) {
        if (typeof this.backgroundColor === 'string') {
          ctx.fillStyle = this.backgroundColor;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        if (typeof this.borderColor === 'string' && typeof this.borderWeight === 'number' && this.borderWeight > 0) {
          ctx.strokeStyle = this.borderColor;
          ctx.lineWidth = this.borderWeight;
          ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
      }
    }, {
      key: "getBounds",
      value: function getBounds() {
        return {
          'l': this.x,
          't': this.y,
          'r': this.x + this.width,
          'b': this.y - this.height
        };
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        if (entity.type === 'rectangle' || entity.type === 'image') {
          var a = this.getBounds();
          var b = entity.getBounds();
          return a.l < b.r && a.r > b.l && a.t > b.b && a.b < b.t;
        } else if (entity.type === 'circle') {
          // Adapted from https://yal.cc/rectangle-circle-intersection-test/
          var deltaX = entity.x - Math.max(this.x, Math.min(entity.x, this.x + this.width));
          var deltaY = entity.y - Math.max(this.y, Math.min(entity.y, this.y + this.height));
          return Math.pow(deltaX, 2) + Math.pow(deltaY, 2) < Math.pow(entity.radius, 2);
        } else throw new Error('Cannot check touches for type ' + entity.type + '.');
      }
    }]);

    return Rectangle;
  }();

  build['Rectangle'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function () {
    function Renderer(element) {
      var _this2 = this;

      var autoRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck(this, Renderer);

      this.element = element;
      this.ctx = this.element.getContext('2d');
      this.entities = [];

      if (autoRender) {
        this._repeatRender = function () {
          _this2.render();

          window.requestAnimationFrame(_this2._repeatRender);
        };

        this._repeatRender();
      }
    }

    _createClass(Renderer, [{
      key: "render",
      value: function render() {
        this._clearCanvas();

        for (var i = 0; i < this.entities.length; i++) {
          this.entities[i].render(this.ctx);
        }
      }
    }, {
      key: "add",
      value: function add(entity) {
        this.entities.push(entity);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.entities = [];
      }
    }, {
      key: "_clearCanvas",
      value: function _clearCanvas() {
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.element.width, this.element.height);
        this.ctx.restore();
      }
    }]);

    return Renderer;
  }();

  build['Renderer'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function () {
    function Text(options) {
      _classCallCheck(this, Text);

      this.type = 'text';
      Object.assign(this, {
        'x': 0,
        'y': 0,
        'text': '',
        'color': '#000000',
        'font': '20px Arial',
        'alignment': 'start'
      }, options); // 'maxWidth' option will be undefined by default.
    }

    _createClass(Text, [{
      key: "render",
      value: function render(ctx) {
        ctx.fillStyle = this.color;
        ctx.font = this.font;
        ctx.textAlign = this.alignment;
        ctx.fillText(this.text, this.x, this.y, this.maxWidth);
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        throw new Error('Cannot check touches for type ' + this.type + '.');
      }
    }]);

    return Text;
  }();

  build['Text'] = module.exports;
  return build;
}();