"use strict";

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var canvax = function () {
  var build = {};
  var module = {};

  module.exports =
  /*#__PURE__*/
  function () {
    function Entity() {
      _classCallCheck(this, Entity);

      this.listeners = {
        'mousedown': [],
        'click': []
      };
    }

    _createClass(Entity, [{
      key: "on",
      value: function on(event, call) {
        if (this.listeners.hasOwnProperty(event)) {
          this.listeners[event].push(call);
        } else throw new Error('This entity does not emit event \'' + event + '\'.');
      }
    }, {
      key: "emit",
      value: function emit(event, data) {
        for (var i = 0; i < this.listeners[event].length; i++) {
          this.listeners[event][i](data);
        }
      }
    }, {
      key: "getEventPosition",
      value: function getEventPosition(e, renderer) {
        var rect = renderer.element.getBoundingClientRect();
        return {
          'x': e.clientX - rect.left,
          'y': e.clientY - rect.top
        };
      }
    }]);

    return Entity;
  }();

  build['Entity'] = module.exports;
  var Entity = build['Entity'];

  module.exports =
  /*#__PURE__*/
  function (_ref) {
    _inherits(Circle, _ref);

    function Circle(options) {
      var _this;

      _classCallCheck(this, Circle);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this));
      _this.type = 'circle';
      _this.clicked = false;
      Object.assign(_assertThisInitialized(_this), {
        'x': 0,
        'y': 0,
        'radius': 100,
        'backgroundColor': null,
        'borderColor': '#E74C3C',
        'borderWeight': 0
      }, options);
      return _this;
    }

    _createClass(Circle, [{
      key: "processCanvasEvent",
      value: function processCanvasEvent(e, renderer) {
        var point = this.getEventPosition(e, renderer);

        if (e.type === 'mousedown') {
          if (this.touchesPoint(point)) {
            this.emit('mousedown');
            this.clicked = true;
          }
        } else if (e.type === 'mouseup') {
          if (this.touchesPoint(point) && this.clicked) {
            this.emit('click');
          }

          this.clicked = false;
        }
      }
    }, {
      key: "render",
      value: function render(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);

        if (typeof this.backgroundColor === 'string') {
          ctx.fillStyle = this.backgroundColor;
          ctx.fill();
        }

        if (typeof this.borderColor === 'string' && typeof this.borderWeight === 'number' && this.borderWeight > 0) {
          ctx.strokeStyle = this.borderColor;
          ctx.lineWidth = this.borderWeight;
          ctx.stroke();
        }
      }
    }, {
      key: "touchesPoint",
      value: function touchesPoint(point) {
        return Math.sqrt(Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2)) <= this.radius;
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        if (entity.type === 'circle') {
          return this._pointDistance([this.x, this.y], [entity.x, entity.y]) < this.radius + entity.radius;
        } else if (entity.type === 'rectangle' || entity.type === 'image') {
          // Adapted from https://yal.cc/rectangle-circle-intersection-test/
          var deltaX = this.x - Math.max(entity.x, Math.min(this.x, entity.x + entity.width));
          var deltaY = this.y - Math.max(entity.y, Math.min(this.y, entity.y + entity.height));
          return Math.pow(deltaX, 2) + Math.pow(deltaY, 2) < Math.pow(this.radius, 2);
        } else throw new Error('Cannot check touches for type ' + entity.type + '.');
      }
    }, {
      key: "_pointDistance",
      value: function _pointDistance(p1, p2) {
        return Math.sqrt(Math.pow(Math.abs(p1[0] - p2[0]), 2) + Math.pow(Math.abs(p1[1] - p2[1]), 2));
      }
    }]);

    return Circle;
  }(_typeof(Entity) === 'object' || typeof require !== 'function' ? Entity : require(require('path').join(__dirname, 'Entity.js')));

  build['Circle'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function (_ref2) {
    _inherits(Ellipse, _ref2);

    function Ellipse(options) {
      var _this2;

      _classCallCheck(this, Ellipse);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Ellipse).call(this));
      _this2.type = 'ellipse';
      _this2.listeners = {};
      Object.assign(_assertThisInitialized(_this2), {
        'x': 0,
        'y': 0,
        'width': 100,
        'height': 100,
        'backgroundColor': null,
        'borderColor': '#E74C3C',
        'borderWeight': 0
      }, options);
      return _this2;
    }

    _createClass(Ellipse, [{
      key: "processCanvasEvent",
      value: function processCanvasEvent(e, renderer) {}
    }, {
      key: "render",
      value: function render(ctx) {
        var kappa = .5522847493;
        var ox = this.width / 2 * kappa;
        var oy = this.height / 2 * kappa;
        var xe = this.x + this.width;
        var ye = this.y + this.height;
        var xm = this.x + this.width / 2;
        var ym = this.y + this.height / 2;
        ctx.beginPath();
        ctx.moveTo(this.x, ym);
        ctx.bezierCurveTo(this.x, ym - oy, xm - ox, this.y, xm, this.y);
        ctx.bezierCurveTo(xm + ox, this.y, xe, ym - oy, xe, ym);
        ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        ctx.bezierCurveTo(xm - ox, ye, this.x, ym + oy, this.x, ym);
        ctx.closePath();

        if (typeof this.backgroundColor === 'string') {
          ctx.fillStyle = this.backgroundColor;
          ctx.fill();
        }

        if (typeof this.borderColor === 'string' && typeof this.borderWeight === 'number' && this.borderWeight > 0) {
          ctx.strokeStyle = this.borderColor;
          ctx.lineWidth = this.borderWeight;
          ctx.stroke();
        }
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        throw new Error('Cannot check touches for type ' + this.type + '.');
      }
    }]);

    return Ellipse;
  }(_typeof(Entity) === 'object' || typeof require !== 'function' ? Entity : require(require('path').join(__dirname, 'Entity.js')));

  build['Ellipse'] = module.exports;
  var __canvaxImageCache = {};

  module.exports =
  /*#__PURE__*/
  function (_ref3) {
    _inherits(Image, _ref3);

    function Image(options) {
      var _this3;

      _classCallCheck(this, Image);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Image).call(this));
      _this3.type = 'image';
      _this3.clicked = false;
      Object.assign(_assertThisInitialized(_this3), {
        'x': 0,
        'y': 0,
        'source': ''
      }, options); // 'width' and 'height' options will be undefined by default.

      return _this3;
    }

    _createClass(Image, [{
      key: "processCanvasEvent",
      value: function processCanvasEvent(e, renderer) {
        var point = this.getEventPosition(e, renderer);

        if (e.type === 'mousedown') {
          if (this.touchesPoint(point)) {
            this.emit('mousedown');
            this.clicked = true;
          }
        } else if (e.type === 'mouseup') {
          if (this.touchesPoint(point) && this.clicked) {
            this.emit('click');
          }

          this.clicked = false;
        }
      }
    }, {
      key: "render",
      value: function render(ctx) {
        var _this4 = this;

        ctx.rotate(this.rotation * Math.PI / 180);
        var imageSource;

        if (__canvaxImageCache.hasOwnProperty(this.source)) {
          if (__canvaxImageCache[this.source] === false) return;
          imageSource = __canvaxImageCache[this.source];
          ctx.drawImage(imageSource, this.x, this.y, this.width, this.height);
        } else {
          __canvaxImageCache[this.source] = false;
          imageSource = document.createElement('img');
          imageSource.src = this.source;

          imageSource.onload = function () {
            __canvaxImageCache[_this4.source] = imageSource;
            ctx.drawImage(imageSource, _this4.x, _this4.y, _this4.width, _this4.height);
          };
        }
      }
    }, {
      key: "getBounds",
      value: function getBounds() {
        return {
          'l': this.x,
          't': this.y,
          'r': this.x + this.width,
          'b': this.y - this.height
        };
      }
    }, {
      key: "touchesPoint",
      value: function touchesPoint(point) {
        return point.x > this.x && point.x < this.x + this.width && point.y > this.y && point.y < this.y + this.height;
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        if (entity.type === 'rectangle' || entity.type === 'image') {
          var myBounds = this.getBounds();
          var checkBounds = entity.getBounds();
          return !(myBounds.t < checkBounds.b || myBounds.b > checkBounds.t || myBounds.r < checkBounds.l || myBounds.l > checkBounds.r);
        } else if (entity.type === 'circle') {
          // Adapted from https://yal.cc/rectangle-circle-intersection-test/
          var deltaX = entity.x - Math.max(this.x, Math.min(entity.x, this.x + this.width));
          var deltaY = entity.y - Math.max(this.y, Math.min(entity.y, this.y + this.height));
          return Math.pow(deltaX, 2) + Math.pow(deltaY, 2) < Math.pow(entity.radius, 2);
        } else throw new Error('Cannot check touches for type ' + entity.type + '.');
      }
    }]);

    return Image;
  }(_typeof(Entity) === 'object' || typeof require !== 'function' ? Entity : require(require('path').join(__dirname, 'Entity.js')));

  build['Image'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function (_ref4) {
    _inherits(Rectangle, _ref4);

    function Rectangle(options) {
      var _this5;

      _classCallCheck(this, Rectangle);

      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Rectangle).call(this));
      _this5.type = 'rectangle';
      _this5.clicked = false;
      Object.assign(_assertThisInitialized(_this5), {
        'x': 0,
        'y': 0,
        'width': 100,
        'height': 100,
        'backgroundColor': null,
        'borderColor': '#E74C3C',
        'borderWeight': 0
      }, options);
      return _this5;
    }

    _createClass(Rectangle, [{
      key: "processCanvasEvent",
      value: function processCanvasEvent(e, renderer) {
        var point = this.getEventPosition(e, renderer);

        if (e.type === 'mousedown') {
          if (this.touchesPoint(point)) {
            this.emit('mousedown');
            this.clicked = true;
          }
        } else if (e.type === 'mouseup') {
          if (this.touchesPoint(point) && this.clicked) {
            this.emit('click');
          }

          this.clicked = false;
        }
      }
    }, {
      key: "render",
      value: function render(ctx) {
        if (typeof this.backgroundColor === 'string') {
          ctx.fillStyle = this.backgroundColor;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        if (typeof this.borderColor === 'string' && typeof this.borderWeight === 'number' && this.borderWeight > 0) {
          ctx.strokeStyle = this.borderColor;
          ctx.lineWidth = this.borderWeight;
          ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
      }
    }, {
      key: "getBounds",
      value: function getBounds() {
        return {
          'l': this.x,
          't': this.y,
          'r': this.x + this.width,
          'b': this.y - this.height
        };
      }
    }, {
      key: "touchesPoint",
      value: function touchesPoint(point) {
        return point.x > this.x && point.x < this.x + this.width && point.y > this.y && point.y < this.y + this.height;
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        if (entity.type === 'rectangle' || entity.type === 'image') {
          var a = this.getBounds();
          var b = entity.getBounds();
          return a.l < b.r && a.r > b.l && a.t > b.b && a.b < b.t;
        } else if (entity.type === 'circle') {
          // Adapted from https://yal.cc/rectangle-circle-intersection-test/
          var deltaX = entity.x - Math.max(this.x, Math.min(entity.x, this.x + this.width));
          var deltaY = entity.y - Math.max(this.y, Math.min(entity.y, this.y + this.height));
          return Math.pow(deltaX, 2) + Math.pow(deltaY, 2) < Math.pow(entity.radius, 2);
        } else throw new Error('Cannot check touches for type ' + entity.type + '.');
      }
    }]);

    return Rectangle;
  }(_typeof(Entity) === 'object' || typeof require !== 'function' ? Entity : require(require('path').join(__dirname, 'Entity.js')));

  build['Rectangle'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function () {
    function Renderer(element) {
      var _this6 = this;

      var autoRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck(this, Renderer);

      this.element = element;
      this.ctx = this.element.getContext('2d');
      this.entities = [];

      if (autoRender) {
        this._repeatRender = function () {
          _this6.render();

          window.requestAnimationFrame(_this6._repeatRender);
        };

        this._repeatRender();
      }

      this.element.addEventListener('mousedown', function (e) {
        return _this6.sendEvent(e);
      });
      this.element.addEventListener('mouseup', function (e) {
        return _this6.sendEvent(e);
      });
    }

    _createClass(Renderer, [{
      key: "sendEvent",
      value: function sendEvent(e) {
        for (var i = 0; i < this.entities.length; i++) {
          this.entities[i].processCanvasEvent(e, this);
        }
      }
    }, {
      key: "render",
      value: function render() {
        this._clearCanvas();

        for (var i = 0; i < this.entities.length; i++) {
          this.entities[i].render(this.ctx);
        }
      }
    }, {
      key: "add",
      value: function add(entity) {
        this.entities.push(entity);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.entities = [];
      }
    }, {
      key: "_clearCanvas",
      value: function _clearCanvas() {
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.element.width, this.element.height);
        this.ctx.restore();
      }
    }]);

    return Renderer;
  }();

  build['Renderer'] = module.exports;

  module.exports =
  /*#__PURE__*/
  function (_ref5) {
    _inherits(Text, _ref5);

    function Text(options) {
      var _this7;

      _classCallCheck(this, Text);

      _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this));
      _this7.type = 'text';
      _this7.listeners = {};
      Object.assign(_assertThisInitialized(_this7), {
        'x': 0,
        'y': 0,
        'text': '',
        'color': '#000000',
        'font': '20px Arial',
        'alignment': 'start'
      }, options); // 'maxWidth' option will be undefined by default.

      return _this7;
    }

    _createClass(Text, [{
      key: "processCanvasEvent",
      value: function processCanvasEvent(e, renderer) {}
    }, {
      key: "render",
      value: function render(ctx) {
        ctx.fillStyle = this.color;
        ctx.font = this.font;
        ctx.textAlign = this.alignment;
        ctx.fillText(this.text, this.x, this.y, this.maxWidth);
      }
    }, {
      key: "touches",
      value: function touches(entity) {
        throw new Error('Cannot check touches for type ' + this.type + '.');
      }
    }]);

    return Text;
  }(_typeof(Entity) === 'object' || typeof require !== 'function' ? Entity : require(require('path').join(__dirname, 'Entity.js')));

  build['Text'] = module.exports;
  return build;
}();